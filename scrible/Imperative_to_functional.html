<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>1&nbsp;Imperative to functional</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Designing Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Imperative to functional</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Interpreters.html" class="tocviewlink" data-pltdoc="x">Interpreters</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Designing_a_Language_in_Racket.html" class="tocviewlink" data-pltdoc="x">Designing a Language in Racket</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Documenting_and_learning_pattern_matching.html" class="tocviewlink" data-pltdoc="x">Documenting and learning pattern matching</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Imperative to functional</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#%28part._language%29" class="tocviewlink" data-pltdoc="x">Learning a Programming Language</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#%28part._.Transition%29" class="tocviewlink" data-pltdoc="x">Transition from imperative to functional</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#%28part._.Egs%29" class="tocviewlink" data-pltdoc="x">let, let*, letrec and define</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="#%28part._macros%29" class="tocviewlink" data-pltdoc="x">Macros</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._language%29" class="tocsubseclink" data-pltdoc="x">Learning a Programming Language</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Transition%29" class="tocsubseclink" data-pltdoc="x">Transition from imperative to functional</a></td></tr><tr><td><span class="tocsublinknumber">1.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Concepts%29" class="tocsubseclink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td><span class="tocsublinknumber">1.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Types%29" class="tocsubseclink" data-pltdoc="x">Type Systems</a></td></tr><tr><td><span class="tocsublinknumber">1.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Sugar%29" class="tocsubseclink" data-pltdoc="x">Syntactic sugar and macros</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Egs%29" class="tocsubseclink" data-pltdoc="x">let, let*, letrec and define</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._macros%29" class="tocsubseclink" data-pltdoc="x">Macros</a></td></tr><tr><td><span class="tocsublinknumber">1.4.1<tt>&nbsp;</tt></span><a href="#%28part._hygienemacros%29" class="tocsubseclink" data-pltdoc="x">Hygiene Macros</a></td></tr><tr><td><span class="tocsublinknumber">1.4.2<tt>&nbsp;</tt></span><a href="#%28part._patternmatching%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td><span class="tocsublinknumber">1.4.3<tt>&nbsp;</tt></span><a href="#%28part._.Syntaxpattern%29" class="tocsubseclink" data-pltdoc="x">Syntax Pattern</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.9</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Designing Languages&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Designing Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Interpreters.html" title="forward to &quot;2 Interpreters&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._.Imperative_to_functional)"></a>Imperative to functional</h3><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._language%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>Learning a Programming Language</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Transition%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>Transition from imperative to functional</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Concepts%29" class="toclink" data-pltdoc="x">1.2.1<span class="hspace">&nbsp;</span>Language Concepts</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types%29" class="toclink" data-pltdoc="x">1.2.2<span class="hspace">&nbsp;</span>Type Systems</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Sugar%29" class="toclink" data-pltdoc="x">1.2.3<span class="hspace">&nbsp;</span>Syntactic sugar and macros</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Egs%29" class="toclink" data-pltdoc="x">1.3<span class="hspace">&nbsp;</span>let, let*, letrec and define</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._macros%29" class="toclink" data-pltdoc="x">1.4<span class="hspace">&nbsp;</span>Macros</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._hygienemacros%29" class="toclink" data-pltdoc="x">1.4.1<span class="hspace">&nbsp;</span>Hygiene Macros</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._patternmatching%29" class="toclink" data-pltdoc="x">1.4.2<span class="hspace">&nbsp;</span>Pattern Matching</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Syntaxpattern%29" class="toclink" data-pltdoc="x">1.4.3<span class="hspace">&nbsp;</span>Syntax Pattern</a></p></td></tr></table></div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>I need to add concrete racket examples to explain
these concepts a little better.</p></blockquote></blockquote></blockquote></div></p><h4>1.1<tt>&nbsp;</tt><a name="(part._language)"></a>Learning a Programming Language</h4><p><div class="SIntrapara">Learning any programming language requires a lot of effort and investment
of time.
The most precise way to look at what a language really contains is
something that I picked up from Dan Grossman&rsquo;s video according to which
there are five things that are required in the process to master any
programming language.
</div><div class="SIntrapara"><ul><li><p>Syntax: This is perhaps the most obvious bit when we look at a
programming language.</p></li><li><p>Semantics: This is what gives meaning to the above syntax</p></li><li><p>Idioms: These are which features of the language should be used when; means
that we have the notion of tuples and records in functional languages, tuples are
syntactic sugar on record, when should tuples be used and when should records be used?
especially since they are pretty much the same things.</p></li><li><p>Libraries: This one is quite obvious, basically something like language extensions
since the more hold we have on the libraries and their understanding, the bigger software
we will be able to write with much ease.</p></li><li><p>Tools: For every language, debugging and other such tools are very important to understand.
Again this can speed up the process.</p></li></ul></div></p><p>The important thing according to me (and after watching Dan Grossman&rsquo;s lectures) is that
understanding the semantics and idioms is probably the important bits.
Previously when I learned the imperative language I never really focused on the
understanding the semantics in depth.
My core focus was on libraries and seeing what does what. However, now I can see why that
was not the most appropriate way to proceed when learning a programming language.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Transition)"></a>Transition from imperative to functional</h4><p>The languages that I have previously coded in are C, C++, Java, Python.
The general concepts overall were quite similar for me.
Also, when I worked with the above mentioned languages my core focus
was the application rather than learning about the language.
Hence, this is the reason I concentrated more on learning the libraries
and using them for the application than understanding the semantics or the
idioms.</p><h5>1.2.1<tt>&nbsp;</tt><a name="(part._.Concepts)"></a>Language Concepts</h5><p>Based on my past experience I did not find imperative style languages to have a lot of
concepts in general.
They are pretty straighforward (but I am sure that&rsquo;s subjective opinion.)</p><p>Also, the concepts which do exist in those languages are quite different from the ones
found in functional style languages.
The main difference is in the existance of states in imperative style languages.
The existance of states allows the languages to track the variable values in a program
to understand where the program is currently at.
The states or the values in the states are updated based on how the program transitions
in the next step.</p><p>Due to this imperative languages have a lot of power that allows mutability of variables
when transitioning from one state to another.</p><p>In functional style languages states do not exist and since everything is written in form
of a lambda, and there are many many interesting concepts such as different notons for defining
bindings in functional languages.</p><p>In Racket, the reason I specifically mention Racket because it is the first language I
am actually putting in real effort to understand the language design.</p><h5>1.2.2<tt>&nbsp;</tt><a name="(part._.Types)"></a>Type Systems</h5><p>Another interesting thing that I found about functional style languages was the existance of
types.
Before entering the functional language wonderland, I really did not know that types could
play such a significant role in the world of programming languages.
The most introduction that I have had to the world of types were the datatypes that are used
in C type languages.
Maybe there was more to look into there too, however, I never paid much attention to it.</p><p>In a very high level explanation the existance of types definitely helps in finding more
errors in the programs.</p><h5>1.2.3<tt>&nbsp;</tt><a name="(part._.Sugar)"></a>Syntactic sugar and macros</h5><p>I was introduced to the beautiful concepts of syntactic sugar and macros as I proceeded
towards learning Racket in more depth.
Sugar is the syntax wrapper to ease the implementation of certain things such as tuples
are syntactic sugar for records.</p><p>Also, the most I knew about macros were that they expand out the code and to be really
honest I saw them as something similar to functions.
However, getting introduced to macros in the functional world land, the thing that I have
realised is that macros are such a beautiful concept.</p><p>The mappings of certain keywords to the their expansion is not entirely as trivial
as I thought it would be.
There is still a lot that I do not entirely understand but I think there is a lot to
learn from that and understand the tricks that are going on in there.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Egs)"></a>let, let*, letrec and define</h4><p>Why do I have a seperate section on this?
Well, these are some of the interesting things that I found while learning Racket.</p><p>This really helped me understand "how semantics play an important role in understanding
certain things".
The core purpose of these three is mostly for bindings.
However, these three have different purposes in terms and have different semantics.</p><p>This is the first time I noticed in practice how small modifications in the semantics
can be so useful.
Before this my thinking was in a different direction where while designing the semantics
I would try to observe the real thing and try to model that exactly the way i saw it,
it only took me some time to realise that that is not the case.</p><p>When one is trying to design the semantics for a language, i think that it is important
to stop thinking about the application entirely and only concentrate on different ways
in which the semantics can be tweaked.
This is what I was missing out I think.</p><p>Understanding the scope of each binding that the constructors (let, let*, letrec and define)
provide is very important.</p><p>Example 1:</p><p><span class="RktPn">(</span><span class="RktSym">let</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">b</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">c</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>This evaluates a normal 7 as the output.</p><p>Example 2:
<span class="RktPn">(</span><span class="RktSym">let</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">c</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>In this case, we get an error because let does not allow us to use a to bind to b.</p><p>Example 3:
<span class="RktPn">(</span><span class="RktSym">let*</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktSym">c</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>When we try the simple scene that we do in case of let*, this allows us to
use a to bind it to b.</p><p>The main reason is because let when we open it, the definition becomes something like,</p><p>Example 3a:
<span class="RktPn">(</span><span class="RktSym">let</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">a</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">c</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">b</span><span class="stt"> </span><span class="RktSym">c</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p><div class="SIntrapara">Observations:
</div><div class="SIntrapara"><ul><li><p>let does not allow any referencing within its definition scope.</p></li><li><p>let* allows that since we can see in Example 3a how it really breaks down.</p></li></ul></div></p><h4>1.4<tt>&nbsp;</tt><a name="(part._macros)"></a>Macros</h4><p>I think from my current understanding that Macros are the most precious
things that Racket has probably introduced.
These are functions that run at compiler time.</p><p>There are layers of macros that can exist.
The previous intution that I had about macros from programming languages
such as C and such were that macros are simple "expanders".
They replace a small piece of a code by a bigger piece of code by expanding
it out.</p><p>However, they are much more than that.</p><p><span class="RktPn">(</span><span class="RktSym">define-macro</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">report</span><span class="stt"> </span><span class="RktSym">EXPR</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">begin</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">displayln</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">format</span><span class="stt"> </span><span class="RktVal">"input was ~a"</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">EXPR</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">EXPR</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p><span class="RktPn">(</span><span class="RktSym">report</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Problem every line of code has to have a seperate racket. This
makes typesetting the code a little difficult. Did not expect this blasphemy.</p></blockquote></blockquote></blockquote><h5>1.4.1<tt>&nbsp;</tt><a name="(part._hygienemacros)"></a>Hygiene Macros</h5><p>In the previous part we learned how to define macros, however, we need a
policy system to actually define macros and do something with that.
Hygiene is that policy system and an essential ingredient to understanding
how to really define macros.</p><p>Before knowing anything about macros as I have mentioned above, I thought
that these are some magical constructs in the Racket universe, however,
now with a little more understanding I see how interesting it is to
understand what Hygiene really signifies here.</p><p>The two core problems that one can encounter during the defining
macros are: bindings and identifiers.
Bindings because these are the ones that map the values to the
identifiers and identifiers because these are the different names
that appear in the program.</p><p>There are basically two ways to reason about bindings and identifiers
that are: 1) use the bindings depending on the place the macro was
defined, this is known as the definition site
2) get the bindings depending on where the macro is being invoked.</p><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="stt"> </span><span class="RktSym">y</span><span class="stt"> </span><span class="RktVal">42</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">define-macro</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">mac1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">begin</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="stt"> </span><span class="RktSym">y</span><span class="stt"> </span><span class="RktVal">88</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">println</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mac1</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">println</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span></p><h5>1.4.2<tt>&nbsp;</tt><a name="(part._patternmatching)"></a>Pattern Matching</h5><p>I think from what I have observed and absorbed from my surroundings is how
interesting pattern matching can really be.</p><p>Using macros and their helper functions, pattern matching can really be
played around with.</p><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="stt"> </span><span class="RktSym">stx</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">foo</span><span class="stt"> </span><span class="RktSym">bar</span><span class="stt"> </span><span class="RktSym">uganda</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p><span class="RktPn">(</span><span class="RktSym">syntax-&gt;datum</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">with-pattern</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">FIRST</span><span class="stt"> </span><span class="RktSym">SECOND</span><span class="stt"> </span><span class="RktSym">THIRD</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">stx</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktSym">FIRST</span><span class="stt"> </span><span class="RktSym">SECOND</span><span class="stt"> </span><span class="RktSym">FIRST</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p><span class="RktPn">(</span><span class="RktSym">syntax-&gt;datum</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">with-pattern</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">FIRST</span><span class="stt"> </span><span class="RktSym">SECOND</span><span class="stt"> </span><span class="RktSym">THIRD</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktSym">FIRST</span><span class="stt"> </span><span class="RktSym">SECOND</span><span class="stt"> </span><span class="RktSym">FIRST</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p><span class="RktPn">(</span><span class="RktSym">syntax-&gt;datum</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">with-pattern</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">FIRST</span><span class="stt"> </span><span class="RktSym">SECOND</span><span class="stt"> </span><span class="RktSym">THIRD</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktVal">12</span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktSym">dd</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktSym">FIRST</span><span class="stt"> </span><span class="RktSym">SECOND</span><span class="stt"> </span><span class="RktSym">FIRST</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p><h5>1.4.3<tt>&nbsp;</tt><a name="(part._.Syntaxpattern)"></a>Syntax Pattern</h5><p>Tool for matching elements within a syntax object.
My use case for understanding these are for using macros
while building languages in beautiful racket.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Link: https://docs.racket-lang.org/br/index.html#(form._((lib._br/define..rkt)._define-macro))</p></blockquote></blockquote></blockquote><p>Define-macros are pretty cool. The reason is that
they allow us to pass a string of words as arguments.</p><p>Base example:</p><p><span class="RktPn">(</span><span class="RktSym">define-macro</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">artistic</span><span class="stt"> </span><span class="RktSym">BB</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktRdr">#'</span><span class="RktPn">(</span><span class="RktSym">format</span><span class="stt"> </span><span class="RktVal">"~a"</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">BB</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">artistic</span><span class="stt"> </span><span class="RktSym">art</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Designing Languages&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Designing Languages&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Interpreters.html" title="forward to &quot;2 Interpreters&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>